{
    "sourceFile": "src/background/background.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1753916664185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1753916674355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -750,4 +750,20 @@\n }\n \n // 添加onInstalled监听器，在安装/更新时初始化\n chrome.runtime.onInstalled.addListener(initialize);\n+\n+// Service Worker 启动时立即初始化\n+// 这确保了浏览器恢复时能够立即处理标签页限制\n+(async () => {\n+  try {\n+    await initialize();\n+  } catch (error) {\n+    console.error('Error during immediate initialization:', error);\n+    // 即使初始化失败，也要尝试设置基本的事件监听器\n+    try {\n+      setupEventListeners();\n+    } catch (setupError) {\n+      console.error('Error setting up event listeners:', setupError);\n+    }\n+  }\n+})();\n"
                },
                {
                    "date": 1753916703745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -602,35 +602,49 @@\n async function applyTabLimitChanges() {\n   return TabManager.executeOperation(async () => {\n     try {\n       if (!TabManager.config.active) {\n+        // 即使功能未激活，也要更新 badge\n+        await TabManager.updateBadgeCount();\n         return;\n       }\n \n       const state = await TabManager.getCurrentTabState();\n+      console.log('Applying tab limit changes. Current state:', {\n+        nonPinnedCount: state.nonPinnedCount,\n+        effectiveLimit: state.effectiveLimit,\n+        hiddenTabsCount: state.hiddenTabsCount,\n+        needsHiding: state.needsHiding,\n+        canRestore: state.canRestore\n+      });\n \n       if (state.needsHiding) {\n         const excessCount = state.nonPinnedTabs.length - state.effectiveLimit;\n+        console.log(`Need to hide ${excessCount} tabs`);\n \n         const tabsToHide = await TabManager.getTabsToHide(excessCount);\n \n         if (tabsToHide.length > 0) {\n+          console.log(`Hiding ${tabsToHide.length} tabs`);\n \n+          // 批量添加到隐藏列表\n           for (const tab of tabsToHide) {\n             TabManager.addHiddenTab(tab);\n           }\n \n           await TabManager.saveHiddenTabs();\n \n+          // 批量移除标签\n           for (const tab of tabsToHide) {\n             try {\n               await chrome.tabs.remove(tab.id);\n             } catch (error) {\n               console.error(`Error removing tab ${tab.id}:`, error);\n             }\n           }\n \n-          TabManager.updateBadgeCount();\n+          // 更新 badge\n+          await TabManager.updateBadgeCount();\n         }\n       }\n       // 如果当前标签数量少于限制，恢复隐藏的标签\n       else if (state.canRestore) {\n@@ -638,8 +652,10 @@\n           state.effectiveLimit - state.nonPinnedTabs.length,\n           state.hiddenTabsCount\n         );\n \n+        console.log(`Can restore ${tabsToRestore} tabs`);\n+\n         const restoredTabs = [];\n         for (let i = 0; i < tabsToRestore; i++) {\n           const tabToRestore = TabManager.hiddenTabs.pop();\n           if (!tabToRestore) break;\n@@ -653,19 +669,33 @@\n             // 记录新标签的访问时间\n             TabManager.updateTabAccessTime(newTab.id);\n             restoredTabs.push(newTab);\n           } catch (error) {\n+            console.error('Error restoring tab:', error);\n             // 如果恢复失败，将标签重新放回隐藏列表\n             TabManager.hiddenTabs.push(tabToRestore);\n           }\n         }\n \n         if (restoredTabs.length > 0) {\n+          console.log(`Restored ${restoredTabs.length} tabs`);\n           await TabManager.saveHiddenTabs();\n-          TabManager.updateBadgeCount();\n         }\n+\n+        // 更新 badge\n+        await TabManager.updateBadgeCount();\n+      } else {\n+        // 即使不需要隐藏或恢复，也要更新 badge\n+        await TabManager.updateBadgeCount();\n       }\n     } catch (error) {\n+      console.error('Error in applyTabLimitChanges:', error);\n+      // 即使出错，也尝试更新 badge\n+      try {\n+        await TabManager.updateBadgeCount();\n+      } catch (badgeError) {\n+        console.error('Error updating badge:', badgeError);\n+      }\n       throw error;\n     }\n   });\n }\n"
                },
                {
                    "date": 1753916786450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,39 +254,42 @@\n   // 更新徽章\n   async updateBadgeCount() {\n     try {\n       switch (this.config.badgeMode) {\n-        case 'open': \n+        case 'open':\n           // 显示打开的标签数量（蓝色）\n           const tabs = await chrome.tabs.query({});\n           const openCount = tabs.length;\n-          chrome.action.setBadgeText({ text: String(openCount) });\n-          chrome.action.setBadgeBackgroundColor({ color: '#2196F3' }); // 蓝色\n-          chrome.action.setBadgeTextColor({ color: 'white' }); // 确保文字是白色\n+          await chrome.action.setBadgeText({ text: String(openCount) });\n+          await chrome.action.setBadgeBackgroundColor({ color: '#2196F3' }); // 蓝色\n+          await chrome.action.setBadgeTextColor({ color: 'white' }); // 确保文字是白色\n+          console.log(`Badge updated: open tabs = ${openCount}`);\n           break;\n-          \n+\n         case 'user':\n           // 显示用户标签数量（绿色）\n           const userTabs = await chrome.tabs.query({});\n           const hiddenUserTabs = this.hiddenTabs.filter(tab => !tab.fromHistory);\n           const userCount = userTabs.length + hiddenUserTabs.length;\n-          chrome.action.setBadgeText({ text: String(userCount) });\n-          chrome.action.setBadgeBackgroundColor({ color: '#4CAF50' });\n-          chrome.action.setBadgeTextColor({ color: 'white' });\n+          await chrome.action.setBadgeText({ text: String(userCount) });\n+          await chrome.action.setBadgeBackgroundColor({ color: '#4CAF50' });\n+          await chrome.action.setBadgeTextColor({ color: 'white' });\n+          console.log(`Badge updated: user tabs = ${userCount}`);\n           break;\n-          \n+\n         case 'hidden':\n         default:\n           // 显示隐藏标签数量（紫色）\n           const count = this.hiddenTabs.length;\n           const text = count > 0 ? String(count) : '';\n-          chrome.action.setBadgeText({ text });\n-          chrome.action.setBadgeBackgroundColor({ color: '#3f50b5' });\n-          chrome.action.setBadgeTextColor({ color: 'white' });\n+          await chrome.action.setBadgeText({ text });\n+          await chrome.action.setBadgeBackgroundColor({ color: '#3f50b5' });\n+          await chrome.action.setBadgeTextColor({ color: 'white' });\n+          console.log(`Badge updated: hidden tabs = ${count}`);\n           break;\n       }\n     } catch (error) {\n-      // 静默处理错误\n+      console.error('Error updating badge count:', error);\n     }\n   },\n   \n \n"
                },
                {
                    "date": 1753916804609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -424,9 +424,9 @@\n   // 立即记录新标签的访问时间\n   TabManager.updateTabAccessTime(tab.id);\n \n   // 更新徽章以反映新标签\n-  TabManager.updateBadgeCount();\n+  await TabManager.updateBadgeCount();\n \n   if (!TabManager.config.active) return;\n \n   // 使用安全操作机制处理标签限制\n"
                },
                {
                    "date": 1753916825010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,9 +454,9 @@\n       // 移除标签\n       await chrome.tabs.remove(tabToHide.id);\n \n       // 更新徽章\n-      TabManager.updateBadgeCount();\n+      await TabManager.updateBadgeCount();\n     } catch (error) {\n       console.error('Error in tab creation operation:', error);\n     }\n   }).catch(error => {\n"
                },
                {
                    "date": 1753916839242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -473,9 +473,9 @@\n     await TabManager.saveTabAccessTimes();\n   }\n \n   // 更新徽章\n-  TabManager.updateBadgeCount();\n+  await TabManager.updateBadgeCount();\n \n   if (isWindowClosing || !TabManager.config.active) return;\n \n   // 使用安全操作机制处理标签恢复\n"
                },
                {
                    "date": 1753916855316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -516,9 +516,9 @@\n         }\n       }\n \n       await TabManager.saveHiddenTabs();\n-      TabManager.updateBadgeCount();\n+      await TabManager.updateBadgeCount();\n     } catch (error) {\n       // 静默处理错误\n     }\n   }).catch(error => {\n"
                },
                {
                    "date": 1753916865589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -531,9 +531,9 @@\n \n \n   try {\n     // 更新徽章\n-    TabManager.updateBadgeCount();\n+    await TabManager.updateBadgeCount();\n \n     // 获取当前标签信息并记录访问时间\n     const tabs = await chrome.tabs.query({windowId});\n     const activeTab = tabs.find(t => t.active);\n"
                },
                {
                    "date": 1753916884974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -553,9 +553,9 @@\n // 处理窗口焦点变化 - 简化为只更新徽章\n async function handleWindowFocusChanged(windowId) {\n \n   if (windowId !== chrome.windows.WINDOW_ID_NONE) {\n-    TabManager.updateBadgeCount();\n+    await TabManager.updateBadgeCount();\n \n     // 当窗口重新获得焦点时，启动自动移动计时器\n     try {\n       const tabs = await chrome.tabs.query({ active: true, windowId });\n"
                },
                {
                    "date": 1753916895437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -583,9 +583,9 @@\n \n // 应用配置到当前状态\n async function applyConfigChanges() {\n   try {\n-    TabManager.updateBadgeCount();\n+    await TabManager.updateBadgeCount();\n     await applyTabLimitChanges();\n \n     // 配置变更时，为当前激活的标签启动自动移动计时器\n     try {\n"
                },
                {
                    "date": 1753916906981,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -740,9 +740,9 @@\n               // 静默处理错误\n             }\n           }\n \n-          TabManager.updateBadgeCount();\n+          await TabManager.updateBadgeCount();\n         }\n       }\n       // 如果当前标签数量少于限制，恢复隐藏的标签\n       else if (state.canRestore) {\n"
                },
                {
                    "date": 1753916917941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -770,9 +770,9 @@\n         }\n \n         if (tabsToRestore > 0) {\n           await TabManager.saveHiddenTabs();\n-          TabManager.updateBadgeCount();\n+          await TabManager.updateBadgeCount();\n         }\n       }\n     } catch (error) {\n       // 静默处理错误\n"
                },
                {
                    "date": 1753917489879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,42 +254,39 @@\n   // 更新徽章\n   async updateBadgeCount() {\n     try {\n       switch (this.config.badgeMode) {\n-        case 'open':\n+        case 'open': \n           // 显示打开的标签数量（蓝色）\n           const tabs = await chrome.tabs.query({});\n           const openCount = tabs.length;\n-          await chrome.action.setBadgeText({ text: String(openCount) });\n-          await chrome.action.setBadgeBackgroundColor({ color: '#2196F3' }); // 蓝色\n-          await chrome.action.setBadgeTextColor({ color: 'white' }); // 确保文字是白色\n-          console.log(`Badge updated: open tabs = ${openCount}`);\n+          chrome.action.setBadgeText({ text: String(openCount) });\n+          chrome.action.setBadgeBackgroundColor({ color: '#2196F3' }); // 蓝色\n+          chrome.action.setBadgeTextColor({ color: 'white' }); // 确保文字是白色\n           break;\n-\n+          \n         case 'user':\n           // 显示用户标签数量（绿色）\n           const userTabs = await chrome.tabs.query({});\n           const hiddenUserTabs = this.hiddenTabs.filter(tab => !tab.fromHistory);\n           const userCount = userTabs.length + hiddenUserTabs.length;\n-          await chrome.action.setBadgeText({ text: String(userCount) });\n-          await chrome.action.setBadgeBackgroundColor({ color: '#4CAF50' });\n-          await chrome.action.setBadgeTextColor({ color: 'white' });\n-          console.log(`Badge updated: user tabs = ${userCount}`);\n+          chrome.action.setBadgeText({ text: String(userCount) });\n+          chrome.action.setBadgeBackgroundColor({ color: '#4CAF50' });\n+          chrome.action.setBadgeTextColor({ color: 'white' });\n           break;\n-\n+          \n         case 'hidden':\n         default:\n           // 显示隐藏标签数量（紫色）\n           const count = this.hiddenTabs.length;\n           const text = count > 0 ? String(count) : '';\n-          await chrome.action.setBadgeText({ text });\n-          await chrome.action.setBadgeBackgroundColor({ color: '#3f50b5' });\n-          await chrome.action.setBadgeTextColor({ color: 'white' });\n-          console.log(`Badge updated: hidden tabs = ${count}`);\n+          chrome.action.setBadgeText({ text });\n+          chrome.action.setBadgeBackgroundColor({ color: '#3f50b5' });\n+          chrome.action.setBadgeTextColor({ color: 'white' });\n           break;\n       }\n     } catch (error) {\n-      console.error('Error updating badge count:', error);\n+      // 静默处理错误\n     }\n   },\n   \n \n@@ -368,12 +365,9 @@\n \n   // 添加事件监听器\n   setupEventListeners();\n \n-  // 立即更新 badge 显示当前状态\n-  await TabManager.updateBadgeCount();\n-\n-  // 应用当前配置到系统状态（这会处理浏览器恢复时的大量标签页）\n+  // 应用当前配置到系统状态\n   await applyConfigChanges();\n \n   // 扩展启动时，为当前激活的标签启动自动移动计时器\n   try {\n@@ -424,9 +418,9 @@\n   // 立即记录新标签的访问时间\n   TabManager.updateTabAccessTime(tab.id);\n \n   // 更新徽章以反映新标签\n-  await TabManager.updateBadgeCount();\n+  TabManager.updateBadgeCount();\n \n   if (!TabManager.config.active) return;\n \n   // 使用安全操作机制处理标签限制\n@@ -454,9 +448,9 @@\n       // 移除标签\n       await chrome.tabs.remove(tabToHide.id);\n \n       // 更新徽章\n-      await TabManager.updateBadgeCount();\n+      TabManager.updateBadgeCount();\n     } catch (error) {\n       console.error('Error in tab creation operation:', error);\n     }\n   }).catch(error => {\n@@ -473,9 +467,9 @@\n     await TabManager.saveTabAccessTimes();\n   }\n \n   // 更新徽章\n-  await TabManager.updateBadgeCount();\n+  TabManager.updateBadgeCount();\n \n   if (isWindowClosing || !TabManager.config.active) return;\n \n   // 使用安全操作机制处理标签恢复\n@@ -516,9 +510,9 @@\n         }\n       }\n \n       await TabManager.saveHiddenTabs();\n-      await TabManager.updateBadgeCount();\n+      TabManager.updateBadgeCount();\n     } catch (error) {\n       // 静默处理错误\n     }\n   }).catch(error => {\n@@ -531,9 +525,9 @@\n \n \n   try {\n     // 更新徽章\n-    await TabManager.updateBadgeCount();\n+    TabManager.updateBadgeCount();\n \n     // 获取当前标签信息并记录访问时间\n     const tabs = await chrome.tabs.query({windowId});\n     const activeTab = tabs.find(t => t.active);\n@@ -553,9 +547,9 @@\n // 处理窗口焦点变化 - 简化为只更新徽章\n async function handleWindowFocusChanged(windowId) {\n \n   if (windowId !== chrome.windows.WINDOW_ID_NONE) {\n-    await TabManager.updateBadgeCount();\n+    TabManager.updateBadgeCount();\n \n     // 当窗口重新获得焦点时，启动自动移动计时器\n     try {\n       const tabs = await chrome.tabs.query({ active: true, windowId });\n@@ -583,9 +577,9 @@\n \n // 应用配置到当前状态\n async function applyConfigChanges() {\n   try {\n-    await TabManager.updateBadgeCount();\n+    TabManager.updateBadgeCount();\n     await applyTabLimitChanges();\n \n     // 配置变更时，为当前激活的标签启动自动移动计时器\n     try {\n@@ -605,49 +599,35 @@\n async function applyTabLimitChanges() {\n   return TabManager.executeOperation(async () => {\n     try {\n       if (!TabManager.config.active) {\n-        // 即使功能未激活，也要更新 badge\n-        await TabManager.updateBadgeCount();\n         return;\n       }\n \n       const state = await TabManager.getCurrentTabState();\n-      console.log('Applying tab limit changes. Current state:', {\n-        nonPinnedCount: state.nonPinnedCount,\n-        effectiveLimit: state.effectiveLimit,\n-        hiddenTabsCount: state.hiddenTabsCount,\n-        needsHiding: state.needsHiding,\n-        canRestore: state.canRestore\n-      });\n \n       if (state.needsHiding) {\n         const excessCount = state.nonPinnedTabs.length - state.effectiveLimit;\n-        console.log(`Need to hide ${excessCount} tabs`);\n \n         const tabsToHide = await TabManager.getTabsToHide(excessCount);\n \n         if (tabsToHide.length > 0) {\n-          console.log(`Hiding ${tabsToHide.length} tabs`);\n \n-          // 批量添加到隐藏列表\n           for (const tab of tabsToHide) {\n             TabManager.addHiddenTab(tab);\n           }\n \n           await TabManager.saveHiddenTabs();\n \n-          // 批量移除标签\n           for (const tab of tabsToHide) {\n             try {\n               await chrome.tabs.remove(tab.id);\n             } catch (error) {\n               console.error(`Error removing tab ${tab.id}:`, error);\n             }\n           }\n \n-          // 更新 badge\n-          await TabManager.updateBadgeCount();\n+          TabManager.updateBadgeCount();\n         }\n       }\n       // 如果当前标签数量少于限制，恢复隐藏的标签\n       else if (state.canRestore) {\n@@ -655,10 +635,8 @@\n           state.effectiveLimit - state.nonPinnedTabs.length,\n           state.hiddenTabsCount\n         );\n \n-        console.log(`Can restore ${tabsToRestore} tabs`);\n-\n         const restoredTabs = [];\n         for (let i = 0; i < tabsToRestore; i++) {\n           const tabToRestore = TabManager.hiddenTabs.pop();\n           if (!tabToRestore) break;\n@@ -672,33 +650,19 @@\n             // 记录新标签的访问时间\n             TabManager.updateTabAccessTime(newTab.id);\n             restoredTabs.push(newTab);\n           } catch (error) {\n-            console.error('Error restoring tab:', error);\n             // 如果恢复失败，将标签重新放回隐藏列表\n             TabManager.hiddenTabs.push(tabToRestore);\n           }\n         }\n \n         if (restoredTabs.length > 0) {\n-          console.log(`Restored ${restoredTabs.length} tabs`);\n           await TabManager.saveHiddenTabs();\n+          TabManager.updateBadgeCount();\n         }\n-\n-        // 更新 badge\n-        await TabManager.updateBadgeCount();\n-      } else {\n-        // 即使不需要隐藏或恢复，也要更新 badge\n-        await TabManager.updateBadgeCount();\n       }\n     } catch (error) {\n-      console.error('Error in applyTabLimitChanges:', error);\n-      // 即使出错，也尝试更新 badge\n-      try {\n-        await TabManager.updateBadgeCount();\n-      } catch (badgeError) {\n-        console.error('Error updating badge:', badgeError);\n-      }\n       throw error;\n     }\n   });\n }\n@@ -740,9 +704,9 @@\n               // 静默处理错误\n             }\n           }\n \n-          await TabManager.updateBadgeCount();\n+          TabManager.updateBadgeCount();\n         }\n       }\n       // 如果当前标签数量少于限制，恢复隐藏的标签\n       else if (state.canRestore) {\n@@ -770,9 +734,9 @@\n         }\n \n         if (tabsToRestore > 0) {\n           await TabManager.saveHiddenTabs();\n-          await TabManager.updateBadgeCount();\n+          TabManager.updateBadgeCount();\n         }\n       }\n     } catch (error) {\n       // 静默处理错误\n@@ -783,20 +747,4 @@\n }\n \n // 添加onInstalled监听器，在安装/更新时初始化\n chrome.runtime.onInstalled.addListener(initialize);\n-\n-// Service Worker 启动时立即初始化\n-// 这确保了浏览器恢复时能够立即处理标签页限制\n-(async () => {\n-  try {\n-    await initialize();\n-  } catch (error) {\n-    console.error('Error during immediate initialization:', error);\n-    // 即使初始化失败，也要尝试设置基本的事件监听器\n-    try {\n-      setupEventListeners();\n-    } catch (setupError) {\n-      console.error('Error setting up event listeners:', setupError);\n-    }\n-  }\n-})();\n"
                }
            ],
            "date": 1753916664185,
            "name": "Commit-0",
            "content": "// background.js - 标签限制器的全部逻辑\n\n// TabManager - 标签管理模块\nconst TabManager = {\n  // 配置存储（sync）\n  config: {\n    active: true,\n    tabLimit: 20,\n    tabsQueueLength: 80,\n    badgeMode: 'open',\n    adaptiveLimit: true,\n    pixelsPerTab: 150,\n    autoMove: {\n      enabled: true,\n      direction: 'left', // 'left' 或 'right'\n      delay: 3000 // 延迟时间（毫秒）\n    }\n  },\n\n  // 隐藏标签存储\n  hiddenTabs: [],\n\n  // 标签访问记录\n  tabAccessTimes: {},\n\n  // 窗口大小变化的定时器ID\n  resizeTimeoutId: null,\n\n  // 操作锁和队列\n  operationLock: false,\n  operationQueue: [],\n\n  // 标签页自动移动相关\n  autoMoveTimerId: null,\n  autoMoveTargetTabId: null,\n\n\n\n  // 安全执行操作，防止并发冲突\n  async executeOperation(operation) {\n    return new Promise((resolve, reject) => {\n      this.operationQueue.push({ operation, resolve, reject });\n      this.processQueue();\n    });\n  },\n\n  // 处理操作队列\n  async processQueue() {\n    if (this.operationLock || this.operationQueue.length === 0) {\n      return;\n    }\n\n    this.operationLock = true;\n\n    try {\n      while (this.operationQueue.length > 0) {\n        const { operation, resolve, reject } = this.operationQueue.shift();\n        try {\n          const result = await operation();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      }\n    } finally {\n      this.operationLock = false;\n    }\n  },\n\n  // 获取当前实际标签状态（实时查询）\n  async getCurrentTabState() {\n    try {\n      const tabs = await chrome.tabs.query({});\n      const nonPinnedTabs = tabs.filter(tab => !tab.pinned);\n      const pinnedTabs = tabs.filter(tab => tab.pinned);\n      const effectiveLimit = await this.getEffectiveTabLimit();\n\n      const state = {\n        timestamp: Date.now(),\n        allTabs: tabs,\n        nonPinnedTabs,\n        pinnedTabs,\n        effectiveLimit,\n        hiddenTabsCount: this.hiddenTabs.length,\n        needsHiding: nonPinnedTabs.length > effectiveLimit,\n        canRestore: nonPinnedTabs.length < effectiveLimit && this.hiddenTabs.length > 0,\n        totalTabCount: tabs.length,\n        nonPinnedCount: nonPinnedTabs.length,\n        pinnedCount: pinnedTabs.length\n      };\n\n      return state;\n    } catch (error) {\n      throw error;\n    }\n  },\n\n\n\n\n\n  // 初始化\n  async init() {\n    try {\n      const {config = {}} = await chrome.storage.sync.get('config');\n      const {hiddenTabs = {}} = await chrome.storage.local.get('hiddenTabs');\n      const {tabAccessTimes = {}} = await chrome.storage.local.get('tabAccessTimes');\n      \n      this.config = {...this.config, ...config};\n      \n      this.hiddenTabs = hiddenTabs;\n      \n      // 加载标签访问时间记录\n      this.tabAccessTimes = tabAccessTimes;\n      \n      console.log('TabManager initialized');\n      return this;\n    } catch (error) {\n      console.error('Error initializing TabManager:', error);\n      return this;\n    }\n  },\n  \n  // 保存配置\n  async saveConfig() {\n    try {\n      await chrome.storage.sync.set({config: this.config});\n    } catch (error) {\n      console.error('Error saving config:', error);\n    }\n  },\n\n  // 保存隐藏标签\n  async saveHiddenTabs() {\n    try {\n      await chrome.storage.local.set({hiddenTabs: this.hiddenTabs});\n    } catch (error) {\n      // 静默处理错误\n    }\n  },\n\n  // 保存标签访问时间记录\n  async saveTabAccessTimes() {\n    try {\n      await chrome.storage.local.set({tabAccessTimes: this.tabAccessTimes});\n    } catch (error) {\n      // 静默处理错误\n    }\n  },\n  \n  // 更新标签访问时间\n  updateTabAccessTime(tabId) {\n    this.tabAccessTimes[tabId] = Date.now();\n    this.saveTabAccessTimes();\n  },\n\n  // 获取隐藏标签 - 不再需要窗口ID\n  getHiddenTabs() {\n    return this.hiddenTabs || [];\n  },\n\n  // 添加隐藏标签\n  addHiddenTab(tab) {\n    this.hiddenTabs.push({\n      url: tab.url || tab.pendingUrl,\n      title: tab.title,\n      favIconUrl: tab.favIconUrl,\n      id: Date.now() + Math.random() * 1000 // 生成唯一ID\n    });\n    \n    // 限制队列长度\n    if (this.hiddenTabs.length > this.config.tabsQueueLength) {\n      this.hiddenTabs.shift();\n    }\n  },\n\n  // 删除隐藏标签\n  removeHiddenTab(tabId) {\n    const index = this.hiddenTabs.findIndex(tab => tab.id == tabId);\n    if (index === -1) return false;\n    \n    this.hiddenTabs.splice(index, 1);\n    return true;\n  },\n\n  // 获取要隐藏的标签\n  async getTabsToHide(maxCount = 1) {\n    try {\n      const state = await this.getCurrentTabState();\n\n      if (!state.needsHiding) {\n        return [];\n      }\n\n      const excessCount = Math.min(maxCount, state.nonPinnedTabs.length - state.effectiveLimit);\n      if (excessCount <= 0) {\n        return [];\n      }\n\n      // 按访问时间排序，最早访问的在前面\n      const sortedTabs = state.nonPinnedTabs.slice().sort((a, b) => {\n        const timeA = this.tabAccessTimes[a.id] || 0;\n        const timeB = this.tabAccessTimes[b.id] || 0;\n\n        // 如果访问时间相同，按索引排序（左边的优先）\n        if (timeA === timeB) {\n          return a.index - b.index;\n        }\n\n        return timeA - timeB;\n      });\n\n      const tabsToHide = sortedTabs.slice(0, excessCount);\n\n      return tabsToHide;\n    } catch (error) {\n      return [];\n    }\n  },\n\n\n  \n  // 获取有效的标签限制数量（考虑窗口宽度）- 不再需要窗口ID\n  async getEffectiveTabLimit() {\n    if (!this.config.adaptiveLimit) {\n      return this.config.tabLimit; // 如果未启用自适应限制，返回固定值\n    }\n    \n    try {\n      // 获取当前窗口信息\n      const windows = await chrome.windows.getAll({windowTypes: ['normal']});\n      if (!windows || !windows.length) return this.config.tabLimit;\n      \n      // 使用当前活动窗口或第一个窗口\n      let currentWindow = windows[0];\n      for (const window of windows) {\n        if (window.focused) {\n          currentWindow = window;\n          break;\n        }\n      }\n      \n      // 根据窗口宽度计算可显示的标签数量\n      const availableWidth = currentWindow.width;\n      const adaptiveLimit = Math.max(5, Math.floor(availableWidth / this.config.pixelsPerTab));\n      \n      // 返回自适应限制和固定限制中较小的值\n      return Math.min(adaptiveLimit, this.config.tabLimit);\n    } catch (error) {\n      return this.config.tabLimit; // 出错时返回固定值\n    }\n  },\n\n  // 更新徽章\n  async updateBadgeCount() {\n    try {\n      switch (this.config.badgeMode) {\n        case 'open': \n          // 显示打开的标签数量（蓝色）\n          const tabs = await chrome.tabs.query({});\n          const openCount = tabs.length;\n          chrome.action.setBadgeText({ text: String(openCount) });\n          chrome.action.setBadgeBackgroundColor({ color: '#2196F3' }); // 蓝色\n          chrome.action.setBadgeTextColor({ color: 'white' }); // 确保文字是白色\n          break;\n          \n        case 'user':\n          // 显示用户标签数量（绿色）\n          const userTabs = await chrome.tabs.query({});\n          const hiddenUserTabs = this.hiddenTabs.filter(tab => !tab.fromHistory);\n          const userCount = userTabs.length + hiddenUserTabs.length;\n          chrome.action.setBadgeText({ text: String(userCount) });\n          chrome.action.setBadgeBackgroundColor({ color: '#4CAF50' });\n          chrome.action.setBadgeTextColor({ color: 'white' });\n          break;\n          \n        case 'hidden':\n        default:\n          // 显示隐藏标签数量（紫色）\n          const count = this.hiddenTabs.length;\n          const text = count > 0 ? String(count) : '';\n          chrome.action.setBadgeText({ text });\n          chrome.action.setBadgeBackgroundColor({ color: '#3f50b5' });\n          chrome.action.setBadgeTextColor({ color: 'white' });\n          break;\n      }\n    } catch (error) {\n      // 静默处理错误\n    }\n  },\n  \n\n\n  // 标签页自动移动功能\n  startAutoMoveTimer(tabId) {\n    if (!this.config.autoMove.enabled) return;\n\n    // 清除之前的计时器\n    this.clearAutoMoveTimer();\n\n    // 保存目标标签ID\n    this.autoMoveTargetTabId = tabId;\n\n    // 启动新的计时器\n    this.autoMoveTimerId = setTimeout(() => {\n      this.executeAutoMove();\n    }, this.config.autoMove.delay);\n  },\n\n  clearAutoMoveTimer() {\n    if (this.autoMoveTimerId) {\n      clearTimeout(this.autoMoveTimerId);\n      this.autoMoveTimerId = null;\n    }\n    this.autoMoveTargetTabId = null;\n  },\n\n  async executeAutoMove() {\n    try {\n      if (!this.config.autoMove.enabled || !this.autoMoveTargetTabId) {\n        return;\n      }\n\n      // 获取当前激活的标签\n      const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n      if (!tabs.length) {\n        console.log('No active tab found, auto move cancelled');\n        this.clearAutoMoveTimer();\n        return;\n      }\n\n      const activeTab = tabs[0];\n\n      // 确保移动的是正确的标签\n      if (activeTab.id !== this.autoMoveTargetTabId) {\n        console.log('Active tab changed, auto move cancelled');\n        this.clearAutoMoveTimer();\n        return;\n      }\n\n      console.log('Executing auto move for tab:', activeTab.id, 'direction:', this.config.autoMove.direction);\n\n      // 执行移动操作\n      if (this.config.autoMove.direction === 'left') {\n        await chrome.tabs.move(activeTab.id, { index: 0 });\n      } else {\n        await chrome.tabs.move(activeTab.id, { index: -1 });\n      }\n\n      // 清理计时器\n      this.clearAutoMoveTimer();\n    } catch (error) {\n      console.error('Error executing auto move:', error);\n      this.clearAutoMoveTimer();\n    }\n  }\n};\n\n// 初始化\nasync function initialize() {\n  console.log('Initializing background script...');\n\n  // 初始化TabManager\n  await TabManager.init();\n\n  // 添加事件监听器\n  setupEventListeners();\n\n  // 立即更新 badge 显示当前状态\n  await TabManager.updateBadgeCount();\n\n  // 应用当前配置到系统状态（这会处理浏览器恢复时的大量标签页）\n  await applyConfigChanges();\n\n  // 扩展启动时，为当前激活的标签启动自动移动计时器\n  try {\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    if (tabs.length > 0) {\n      TabManager.startAutoMoveTimer(tabs[0].id);\n    }\n  } catch (error) {\n    // 静默处理错误\n  }\n\n  console.log('Initialization complete');\n}\n\n\n\n// 设置事件监听器\nfunction setupEventListeners() {\n  // 标签事件\n  chrome.tabs.onCreated.addListener(handleTabCreated);\n  chrome.tabs.onRemoved.addListener(handleTabRemoved);\n  chrome.tabs.onActivated.addListener(handleTabActivated);\n  \n  // 窗口事件\n  chrome.windows.onFocusChanged.addListener(handleWindowFocusChanged);\n  chrome.windows.onBoundsChanged.addListener(() => {\n    // 防抖处理，避免频繁调用\n    if (TabManager.resizeTimeoutId) {\n      clearTimeout(TabManager.resizeTimeoutId);\n    }\n\n    TabManager.resizeTimeoutId = setTimeout(() => {\n      handleWindowResized();\n    }, 500); // 500ms防抖延迟\n  });\n  \n  // 运行时事件\n  chrome.runtime.onStartup.addListener(initialize);\n  \n  // 存储变化事件\n  chrome.storage.onChanged.addListener(handleStorageChanged);\n}\n\n// 处理标签创建\nasync function handleTabCreated(tab) {\n  console.log('Tab created:', tab.id);\n\n  // 立即记录新标签的访问时间\n  TabManager.updateTabAccessTime(tab.id);\n\n  // 更新徽章以反映新标签\n  TabManager.updateBadgeCount();\n\n  if (!TabManager.config.active) return;\n\n  // 使用安全操作机制处理标签限制\n  TabManager.executeOperation(async () => {\n    try {\n      const state = await TabManager.getCurrentTabState();\n\n      if (!state.needsHiding) {\n        return;\n      }\n\n      const tabsToHide = await TabManager.getTabsToHide(1);\n\n      if (tabsToHide.length === 0) {\n        return;\n      }\n\n      const tabToHide = tabsToHide[0];\n      console.log('Hiding tab due to limit:', tabToHide.id, tabToHide.title?.substring(0, 30));\n\n      // 添加到隐藏列表\n      TabManager.addHiddenTab(tabToHide);\n      await TabManager.saveHiddenTabs();\n\n      // 移除标签\n      await chrome.tabs.remove(tabToHide.id);\n\n      // 更新徽章\n      TabManager.updateBadgeCount();\n    } catch (error) {\n      console.error('Error in tab creation operation:', error);\n    }\n  }).catch(error => {\n    // 静默处理错误\n  });\n}\n\n// 处理标签关闭\nasync function handleTabRemoved(tabId, {isWindowClosing}) {\n  console.log('Tab removed:', tabId);\n\n  if (TabManager.tabAccessTimes[tabId]) {\n    delete TabManager.tabAccessTimes[tabId];\n    await TabManager.saveTabAccessTimes();\n  }\n\n  // 更新徽章\n  TabManager.updateBadgeCount();\n\n  if (isWindowClosing || !TabManager.config.active) return;\n\n  // 使用安全操作机制处理标签恢复\n  TabManager.executeOperation(async () => {\n    try {\n      const state = await TabManager.getCurrentTabState();\n\n      if (!state.canRestore) {\n        return;\n      }\n\n      const tabsToRestore = Math.min(\n        state.effectiveLimit - state.nonPinnedTabs.length,\n        state.hiddenTabsCount\n      );\n\n      if (tabsToRestore <= 0) {\n        return;\n      }\n\n      for (let i = 0; i < tabsToRestore; i++) {\n        const tabToRestore = TabManager.hiddenTabs.pop();\n        if (!tabToRestore) break;\n\n        try {\n          console.log('Restoring tab:', tabToRestore.url?.substring(0, 50));\n          const newTab = await chrome.tabs.create({\n            url: tabToRestore.url,\n            active: false\n          });\n\n          // 记录新标签的访问时间\n          TabManager.updateTabAccessTime(newTab.id);\n        } catch (error) {\n          console.error('Error restoring tab:', error);\n          // 如果恢复失败，将标签重新放回隐藏列表\n          TabManager.hiddenTabs.push(tabToRestore);\n        }\n      }\n\n      await TabManager.saveHiddenTabs();\n      TabManager.updateBadgeCount();\n    } catch (error) {\n      // 静默处理错误\n    }\n  }).catch(error => {\n    // 静默处理错误\n  });\n}\n\n// 处理标签激活\nasync function handleTabActivated({tabId, windowId}) {\n\n\n  try {\n    // 更新徽章\n    TabManager.updateBadgeCount();\n\n    // 获取当前标签信息并记录访问时间\n    const tabs = await chrome.tabs.query({windowId});\n    const activeTab = tabs.find(t => t.active);\n\n    if (!activeTab) return;\n\n    // 更新标签访问时间\n    TabManager.updateTabAccessTime(tabId);\n\n    // 启动自动移动计时器\n    TabManager.startAutoMoveTimer(tabId);\n  } catch (error) {\n    // 静默处理错误\n  }\n}\n\n// 处理窗口焦点变化 - 简化为只更新徽章\nasync function handleWindowFocusChanged(windowId) {\n\n  if (windowId !== chrome.windows.WINDOW_ID_NONE) {\n    TabManager.updateBadgeCount();\n\n    // 当窗口重新获得焦点时，启动自动移动计时器\n    try {\n      const tabs = await chrome.tabs.query({ active: true, windowId });\n      if (tabs.length > 0) {\n        TabManager.startAutoMoveTimer(tabs[0].id);\n      }\n    } catch (error) {\n      // 静默处理错误\n    }\n  }\n}\n\n// 处理存储变化\nfunction handleStorageChanged(changes, areaName) {\n  if (areaName === 'sync' && changes.config) {\n    console.log('Config changed');\n    TabManager.config = changes.config.newValue;\n    applyConfigChanges();\n  } else if (areaName === 'local' && changes.hiddenTabs) {\n    TabManager.hiddenTabs = changes.hiddenTabs.newValue;\n  } else if (areaName === 'local' && changes.tabAccessTimes) {\n    TabManager.tabAccessTimes = changes.tabAccessTimes.newValue;\n  }\n}\n\n// 应用配置到当前状态\nasync function applyConfigChanges() {\n  try {\n    TabManager.updateBadgeCount();\n    await applyTabLimitChanges();\n\n    // 配置变更时，为当前激活的标签启动自动移动计时器\n    try {\n      const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n      if (tabs.length > 0) {\n        TabManager.startAutoMoveTimer(tabs[0].id);\n      }\n    } catch (error) {\n      // 静默处理错误\n    }\n  } catch (error) {\n    // 静默处理错误\n  }\n}\n\n// 应用标签限制\nasync function applyTabLimitChanges() {\n  return TabManager.executeOperation(async () => {\n    try {\n      if (!TabManager.config.active) {\n        return;\n      }\n\n      const state = await TabManager.getCurrentTabState();\n\n      if (state.needsHiding) {\n        const excessCount = state.nonPinnedTabs.length - state.effectiveLimit;\n\n        const tabsToHide = await TabManager.getTabsToHide(excessCount);\n\n        if (tabsToHide.length > 0) {\n\n          for (const tab of tabsToHide) {\n            TabManager.addHiddenTab(tab);\n          }\n\n          await TabManager.saveHiddenTabs();\n\n          for (const tab of tabsToHide) {\n            try {\n              await chrome.tabs.remove(tab.id);\n            } catch (error) {\n              console.error(`Error removing tab ${tab.id}:`, error);\n            }\n          }\n\n          TabManager.updateBadgeCount();\n        }\n      }\n      // 如果当前标签数量少于限制，恢复隐藏的标签\n      else if (state.canRestore) {\n        const tabsToRestore = Math.min(\n          state.effectiveLimit - state.nonPinnedTabs.length,\n          state.hiddenTabsCount\n        );\n\n        const restoredTabs = [];\n        for (let i = 0; i < tabsToRestore; i++) {\n          const tabToRestore = TabManager.hiddenTabs.pop();\n          if (!tabToRestore) break;\n\n          try {\n            const newTab = await chrome.tabs.create({\n              url: tabToRestore.url,\n              active: false\n            });\n\n            // 记录新标签的访问时间\n            TabManager.updateTabAccessTime(newTab.id);\n            restoredTabs.push(newTab);\n          } catch (error) {\n            // 如果恢复失败，将标签重新放回隐藏列表\n            TabManager.hiddenTabs.push(tabToRestore);\n          }\n        }\n\n        if (restoredTabs.length > 0) {\n          await TabManager.saveHiddenTabs();\n          TabManager.updateBadgeCount();\n        }\n      }\n    } catch (error) {\n      throw error;\n    }\n  });\n}\n\n// 为了支持popup.js使用TabManager\nexport { TabManager };\n\n\n\n// 处理窗口大小变化 - 使用安全操作机制\nasync function handleWindowResized() {\n  if (!TabManager.config.active || !TabManager.config.adaptiveLimit) return;\n\n  // 使用安全操作机制处理窗口大小变化\n  TabManager.executeOperation(async () => {\n    try {\n      const state = await TabManager.getCurrentTabState();\n\n      // 如果当前标签数量超过限制，隐藏多余的标签\n      if (state.needsHiding) {\n        const excessCount = state.nonPinnedTabs.length - state.effectiveLimit;\n\n        const tabsToHide = await TabManager.getTabsToHide(excessCount);\n\n        if (tabsToHide.length > 0) {\n\n          // 批量添加到隐藏列表\n          for (const tab of tabsToHide) {\n            TabManager.addHiddenTab(tab);\n          }\n\n          await TabManager.saveHiddenTabs();\n\n          // 批量移除标签\n          for (const tab of tabsToHide) {\n            try {\n              await chrome.tabs.remove(tab.id);\n            } catch (error) {\n              // 静默处理错误\n            }\n          }\n\n          TabManager.updateBadgeCount();\n        }\n      }\n      // 如果当前标签数量少于限制，恢复隐藏的标签\n      else if (state.canRestore) {\n        const tabsToRestore = Math.min(\n          state.effectiveLimit - state.nonPinnedTabs.length,\n          state.hiddenTabsCount\n        );\n\n        for (let i = 0; i < tabsToRestore; i++) {\n          const tabToRestore = TabManager.hiddenTabs.pop();\n          if (!tabToRestore) break;\n\n          try {\n            const newTab = await chrome.tabs.create({\n              url: tabToRestore.url,\n              active: false\n            });\n\n            // 记录新标签的访问时间\n            TabManager.updateTabAccessTime(newTab.id);\n          } catch (error) {\n            // 如果恢复失败，将标签重新放回隐藏列表\n            TabManager.hiddenTabs.push(tabToRestore);\n          }\n        }\n\n        if (tabsToRestore > 0) {\n          await TabManager.saveHiddenTabs();\n          TabManager.updateBadgeCount();\n        }\n      }\n    } catch (error) {\n      // 静默处理错误\n    }\n  }).catch(error => {\n    // 静默处理错误\n  });\n}\n\n// 添加onInstalled监听器，在安装/更新时初始化\nchrome.runtime.onInstalled.addListener(initialize);\n"
        }
    ]
}